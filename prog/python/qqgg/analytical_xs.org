#+PROPERTY: header-args :exports both :output-dir results

* Init
** Required Modules
#+NAME: e988e3f2-ad1f-49a3-ad60-bedba3863283
#+begin_src ipython :session :exports both :tangle tangled/xs.py
  import numpy as np
  import matplotlib.pyplot as plt
  import monte_carlo
#+end_src

#+RESULTS: e988e3f2-ad1f-49a3-ad60-bedba3863283

** Utilities
#+NAME: 53548778-a4c1-461a-9b1f-0f401df12b08
#+BEGIN_SRC ipython :session :exports both
%run ../utility.py
%load_ext autoreload
%aimport monte_carlo
%autoreload 1
#+END_SRC

#+RESULTS: 53548778-a4c1-461a-9b1f-0f401df12b08

* Implementation
#+NAME: 777a013b-6c20-44bd-b58b-6a7690c21c0e
#+BEGIN_SRC ipython :session :exports both :results raw drawer :exports code :tangle tangled/xs.py
  """
  Implementation of the analytical cross section for q q_bar ->
  gamma gamma

  Author: Valentin Boettcher <hiro@protagon.space>
  """

  import numpy as np
  from scipy.constants import alpha

  # NOTE: a more elegant solution would be a decorator
  def energy_factor(charge, esp):
      """
      Calculates the factor common to all other values in this module

      Arguments:
      esp -- center of momentum energy in GeV
      charge -- charge of the particle in units of the elementary charge
      """

      return charge**4*(alpha/esp)**2/6


  def diff_xs(θ, charge, esp):
      """
      Calculates the differential cross section as a function of the
      azimuth angle θ in units of 1/GeV².

      Arguments:
      θ -- azimuth angle
      esp -- center of momentum energy in GeV
      charge -- charge of the particle in units of the elementary charge
      """

      f = energy_factor(charge, esp)
      return f*((np.cos(θ)**2+1)/np.sin(θ)**2)

  def diff_xs_cosθ(cosθ, charge, esp):
      """
      Calculates the differential cross section as a function of the
      cosine of the azimuth angle θ in units of 1/GeV².

      Arguments:
      cosθ -- cosine of the azimuth angle
      esp -- center of momentum energy in GeV
      charge -- charge of the particle in units of the elementary charge
      """

      f = energy_factor(charge, esp)
      return f*((cosθ**2+1)/(1-cosθ**2))

  def diff_xs_eta(η, charge, esp):
      """
      Calculates the differential cross section as a function of the
      pseudo rapidity of the photons in units of 1/GeV^2.

      Arguments:
      η -- pseudo rapidity
      esp -- center of momentum energy in GeV
      charge -- charge of the particle in units of the elementary charge
      """

      f = energy_factor(charge, esp)
      return f*(2*np.cosh(η)**2 - 1)

  def diff_xs_pt(pt, charge, esp):
      """
      Calculates the differential cross section as a function of the
      transversal impulse of the photons in units of 1/GeV^2.

      Arguments:
      η -- transversal impulse
      esp -- center of momentum energy in GeV
      charge -- charge of the particle in units of the elementary charge
      """

      f = energy_factor(charge, esp)
      return f*((esp/pt)**2/2 - 1)

  def total_xs_eta(η, charge, esp):
      """
      Calculates the total cross section as a function of the pseudo
      rapidity of the photons in units of 1/GeV^2.  If the rapditiy is
      specified as a tuple, it is interpreted as an interval.  Otherwise
      the interval [-η, η] will be used.

      Arguments:
      η -- pseudo rapidity (tuple or number)
      esp -- center of momentum energy in GeV
      charge -- charge of the particle in units of the elementar charge
      """

      f = energy_factor(charge, esp)
      if not isinstance(η, tuple):
          η = (-η, η)

      if len(η) != 2:
          raise ValueError('Invalid η cut.')

      def F(x):
          return np.tanh(x) - 2*x

      return 2*np.pi*f*(F(η[0]) - F(η[1]))
#+END_SRC

#+RESULTS: 777a013b-6c20-44bd-b58b-6a7690c21c0e
:RESULTS:
:END:

* Calculations
** XS qq -> gamma gamma
First, set up the input parameters.
#+NAME: 7e62918a-2935-41ac-94e0-f0e7c3af8e0d
#+BEGIN_SRC ipython :session :exports both :results raw drawer
η = 2.5
charge = 1/3
esp = 200  # GeV
#+END_SRC

Set up the integration and plot intervals.
#+begin_src ipython :session :exports both :results raw drawer
interval_η = [-η, η]
interval = η_to_θ([-η, η])
interval_cosθ = np.cos(interval)
interval_pt = η_to_pt([0, η], esp/2)
plot_interval = [0.1, np.pi-.1]
#+end_src

#+RESULTS:
:RESULTS:
:END:

#+RESULTS: 7e62918a-2935-41ac-94e0-f0e7c3af8e0d
:RESULTS:
:END:

*** Analytical Integratin
And now calculate the cross section in picobarn.
#+NAME: cf853fb6-d338-482e-bc55-bd9f8e796495
#+BEGIN_SRC ipython :session :exports both :results drawer output file :file xs.tex
  xs_gev = total_xs_eta(η, charge, esp)
  xs_pb = gev_to_pb(xs_gev)
  print(tex_value(xs_pb, unit=r'\pico\barn', prefix=r'\sigma = ', prec=5))
#+END_SRC

#+RESULTS: cf853fb6-d338-482e-bc55-bd9f8e796495
:RESULTS:
[[file:results/xs.tex]]
:END:

Compared to sherpa, it's pretty close.
#+NAME: 81b5ed93-0312-45dc-beec-e2ba92e22626
#+BEGIN_SRC ipython :session :exports both :results raw drawer
  sherpa = 0.0538009
  xs_pb/sherpa
#+END_SRC

#+RESULTS: 81b5ed93-0312-45dc-beec-e2ba92e22626
:RESULTS:
0.9998585425137037
:END:

I had to set the runcard option ~EW_SCHEME: alpha0~ to use the pure
QED coupling constant.
*** Numerical Integration

Plot our nice distribution:
#+begin_src ipython :session :exports both :results raw drawer
plot_points = np.linspace(*plot_interval, 1000)

fig, ax = set_up_plot()
ax.plot(plot_points, gev_to_pb(diff_xs(plot_points, charge=charge, esp=esp)))
ax.set_xlabel(r'$\theta$')
ax.set_ylabel(r'$\frac{d\sigma}{d\Omega}$ [pb]')
ax.axvline(interval[0], color='gray', linestyle='--')
ax.axvline(interval[1], color='gray', linestyle='--', label=rf'$|\eta|={η}$')
ax.legend()
save_fig(fig, 'diff_xs', 'xs', size=[4, 4])
#+end_src

#+RESULTS:
:RESULTS:
[[file:./obipy-resources/DHBTl1.png]]
:END:

Define the integrand.
#+begin_src ipython :session :exports both :results raw drawer
  def xs_pb_int(θ):
      return gev_to_pb(np.sin(θ)*diff_xs(θ, charge=charge, esp=esp))
#+end_src

#+RESULTS:
:RESULTS:
:END:

Plot the integrand. # TODO: remove duplication
#+begin_src ipython :session :exports both :results raw drawer
fig, ax = set_up_plot()
ax.plot(plot_points, xs_pb_int(plot_points))
ax.set_xlabel(r'$\theta$')
ax.set_ylabel(r'$\sin(\theta)\cdot\frac{d\sigma}{d\theta}$ [pb]')
ax.axvline(interval[0], color='gray', linestyle='--')
ax.axvline(interval[1], color='gray', linestyle='--', label=rf'$|\eta|={η}$')
ax.legend()
save_fig(fig, 'xs_integrand', 'xs', size=[4, 4])
#+end_src

#+RESULTS:
:RESULTS:
[[file:./obipy-resources/4mne94.png]]
:END:


Intergrate σ with the mc method.
#+begin_src ipython :session :exports both :results raw drawer
  xs_pb_mc, xs_pb_mc_err = monte_carlo.integrate(xs_pb_int, interval, 10000)
  xs_pb_mc = xs_pb_mc*np.pi*2
  xs_pb_mc, xs_pb_mc_err
#+end_src

#+RESULTS:
:RESULTS:
(0.05360809379599215, 4.22681790215136e-05)
:END:

We gonna export that as tex.
#+begin_src ipython :session :exports both :results raw drawer output :file xs_mc.tex
print(tex_value(xs_pb_mc, unit=r'\pico\barn', prefix=r'\sigma = ', prec=5))
#+end_src

#+RESULTS:
:RESULTS:
[[file:results/xs_mc.tex]]
:END:

*** Sampling and Analysis
Define the sample number.
#+begin_src ipython :session :exports both :results raw drawer
  sample_num = 1000
#+end_src

#+RESULTS:
:RESULTS:
:END:


Now we monte-carlo sample our distribution.
#+begin_src ipython :session :exports both :results raw drawer
cosθ_sample = monte_carlo.sample_unweighted_array(sample_num, lambda x:
                                            diff_xs_cosθ(x, charge, esp),
                                            interval_cosθ)
#+end_src

#+RESULTS:
:RESULTS:
:END:

Nice! And now draw some histograms.

We define an auxilliary method for convenience.
#+begin_src ipython :session :exports both :results raw drawer
  def draw_histo(points, xlabel, bins=20):
      fig, ax = set_up_plot()
      ax.hist(points, bins, histtype='step')
      ax.set_xlabel(xlabel)
      ax.set_xlim([points.min(), points.max()])
      return fig, ax
#+end_src

#+RESULTS:
:RESULTS:
:END:

The histogram for cosθ.
#+begin_src ipython :session :exports both :results raw drawer
fig, _ = draw_histo(cosθ_sample, r'$\cos\theta$')
save_fig(fig, 'histo_cos_theta', 'xs', size=(4,3))
#+end_src

#+RESULTS:
:RESULTS:
[[file:./obipy-resources/ZSJaBQ.png]]
:END:

Now we define some utilities to draw real 4-impulse samples.
#+begin_src ipython :session :exports both :tangle tangled/xs.py
  def sample_impulses(sample_num, interval, charge, esp, seed=None):
      """Samples `sample_num` unweighted photon 4-impulses from the cross-section.

      :param sample_num: number of samples to take
      :param interval: cosθ interval to sample from
      :param charge: the charge of the quark
      :param esp: center of mass energy
      :param seed: the seed for the rng, optional, default is system
          time

      :returns: an array of 4 photon impulses
      :rtype: np.ndarray
      """
      cosθ_sample = \
          monte_carlo.sample_unweighted_array(sample_num,
                                              lambda x:
                                                diff_xs_cosθ(x, charge, esp),
                                             interval_cosθ)
      φ_sample = np.random.uniform(0, 1, sample_num)

      def make_impulse(esp, cosθ, φ):
          sinθ = np.sqrt(1-cosθ**2)
          return np.array([1, sinθ*np.cos(φ), sinθ*np.sin(φ), cosθ])*esp/2

      impulses = np.array([make_impulse(esp, cosθ, φ) \
                           for cosθ, φ in np.array([cosθ_sample, φ_sample]).T])
      return impulses
#+end_src

#+RESULTS:

To generate histograms of other obeservables, we have to define them as functions on 4-impuleses.
#+begin_src ipython :session :exports both :results raw drawer :tangle tangled/observables.py
  """This module defines some observables on arrays of 4-pulses."""
  import numpy as np

  def p_t(p):
      """Transverse impulse

      :param p: array of 4-impulses
      """

      return np.linalg.norm(p[:,1:3], axis=1)

  def η(p):
      """Pseudo rapidity.

      :param p: array of 4-impulses
      """

      return np.arccosh(np.linalg.norm(p[:,1:], axis=1)/p_t(p))*np.sign(p[:, 3])
#+end_src

#+RESULTS:
:RESULTS:
:END:


Lets try it out.
#+begin_src ipython :session :exports both :results raw drawer
  impulse_sample = sample_impulses(2000, interval_cosθ, charge, esp)
  impulse_sample
#+end_src

#+RESULTS:
:RESULTS:
#+BEGIN_EXAMPLE
  array([[100.        ,  48.55787717,  64.05713855,  59.48794471],
  [100.        ,  42.68070092,  33.17436113, -84.12977792],
  [100.        ,  18.42611283,  27.20055109, -94.44897239],
  ...,
  [100.        ,  21.40152914,  14.7440014 ,  96.56391134],
  [100.        ,  35.84656512,   5.33864248, -93.20151643],
  [100.        ,  38.37094512,   8.92583559,  91.9130025 ]])
#+END_EXAMPLE
:END:

Now let's make a histogram of the η distribution.
#+begin_src ipython :session :exports both :results raw drawer
  η_sample = η(impulse_sample)
  draw_histo(η_sample, r'$\eta$')
#+end_src

#+RESULTS:
:RESULTS:
#+BEGIN_EXAMPLE
  (<Figure size 432x288 with 1 Axes>,
  <matplotlib.axes._subplots.AxesSubplot at 0x7ff36151dd60>)
#+END_EXAMPLE
[[file:./obipy-resources/S2OvbR.png]]
:END:


And the same for the p_t (transverse impulse) distribution.
#+begin_src ipython :session :exports both :results raw drawer
  p_t_sample = p_t(impulse_sample)
  draw_histo(p_t_sample, r'$p_T$')
#+end_src

#+RESULTS:
:RESULTS:
#+BEGIN_EXAMPLE
  (<Figure size 432x288 with 1 Axes>,
  <matplotlib.axes._subplots.AxesSubplot at 0x7ff364951370>)
#+END_EXAMPLE
[[file:./obipy-resources/nW1TKv.png]]
:END:
