#+PROPERTY: header-args :exports both :output-dir results :session xs :kernel python3

* Init
** Required Modules
#+NAME: e988e3f2-ad1f-49a3-ad60-bedba3863283
#+begin_src jupyter-python :exports both :tangle tangled/xs.py
  import numpy as np
  import matplotlib.pyplot as plt
  import monte_carlo
#+end_src

#+RESULTS: e988e3f2-ad1f-49a3-ad60-bedba3863283

** Utilities
#+NAME: 53548778-a4c1-461a-9b1f-0f401df12b08
#+BEGIN_SRC jupyter-python :exports both
%run ../utility.py
%load_ext autoreload
%aimport monte_carlo
%autoreload 1
#+END_SRC

#+RESULTS: 53548778-a4c1-461a-9b1f-0f401df12b08
: The autoreload extension is already loaded. To reload it, use:
:   %reload_ext autoreload

* Implementation
#+NAME: 777a013b-6c20-44bd-b58b-6a7690c21c0e
#+BEGIN_SRC jupyter-python :exports both :results raw drawer :exports code :tangle tangled/xs.py
  """
  Implementation of the analytical cross section for q q_bar ->
  gamma gamma

  Author: Valentin Boettcher <hiro@protagon.space>
  """

  import numpy as np

  # NOTE: a more elegant solution would be a decorator
  def energy_factor(charge, esp):
      """
      Calculates the factor common to all other values in this module

      Arguments:
      esp -- center of momentum energy in GeV
      charge -- charge of the particle in units of the elementary charge
      """

      return charge**4/(137.036*esp)**2/6


  def diff_xs(θ, charge, esp):
      """
      Calculates the differential cross section as a function of the
      azimuth angle θ in units of 1/GeV².

      Here dΩ=sinθdθdφ

      Arguments:
      θ -- azimuth angle
      esp -- center of momentum energy in GeV
      charge -- charge of the particle in units of the elementary charge
      """

      f = energy_factor(charge, esp)
      return f*((np.cos(θ)**2+1)/np.sin(θ)**2)

  def diff_xs_cosθ(cosθ, charge, esp):
      """
      Calculates the differential cross section as a function of the
      cosine of the azimuth angle θ in units of 1/GeV².

      Here dΩ=d(cosθ)dφ

      Arguments:
      cosθ -- cosine of the azimuth angle
      esp -- center of momentum energy in GeV
      charge -- charge of the particle in units of the elementary charge
      """

      f = energy_factor(charge, esp)
      return f*((cosθ**2+1)/(1-cosθ**2))


  def diff_xs_eta(η, charge, esp):
      """
      Calculates the differential cross section as a function of the
      pseudo rapidity of the photons in units of 1/GeV^2.

      This is actually the crossection dσ/(dφdη).

      Arguments:
      η -- pseudo rapidity
      esp -- center of momentum energy in GeV
      charge -- charge of the particle in units of the elementary charge
      """

      f = energy_factor(charge, esp)
      return f*(np.tanh(η)**2 + 1)


  def diff_xs_p_t(p_t, charge, esp):
      """
      Calculates the differential cross section as a function of the
      transverse momentum (p_t) of the photons in units of 1/GeV^2.

      This is actually the crossection dσ/(dφdp_t).

      Arguments:
      p_t -- transverse momentum in GeV
      esp -- center of momentum energy in GeV
      charge -- charge of the particle in units of the elementary charge
      """

      f = energy_factor(charge, esp)
      sqrt_fact = np.sqrt(1-(2*p_t/esp)**2)
      return f/p_t*(1/sqrt_fact + sqrt_fact)


  def total_xs_eta(η, charge, esp):
      """
      Calculates the total cross section as a function of the pseudo
      rapidity of the photons in units of 1/GeV^2.  If the rapditiy is
      specified as a tuple, it is interpreted as an interval.  Otherwise
      the interval [-η, η] will be used.

      Arguments:
      η -- pseudo rapidity (tuple or number)
      esp -- center of momentum energy in GeV
      charge -- charge of the particle in units of the elementar charge
      """

      f = energy_factor(charge, esp)
      if not isinstance(η, tuple):
          η = (-η, η)

      if len(η) != 2:
          raise ValueError('Invalid η cut.')

      def F(x):
          return np.tanh(x) - 2*x

      return 2*np.pi*f*(F(η[0]) - F(η[1]))
#+END_SRC

#+RESULTS: 777a013b-6c20-44bd-b58b-6a7690c21c0e

* Calculations
** XS qq -> gamma gamma
First, set up the input parameters.
#+BEGIN_SRC jupyter-python :exports both :results raw drawer
η = 2.5
charge = 1/3
esp = 200  # GeV
#+END_SRC

#+RESULTS:

Set up the integration and plot intervals.
#+begin_src jupyter-python :exports both :results raw drawer
interval_η = [-η, η]
interval = η_to_θ([-η, η])
interval_cosθ = np.cos(interval)
interval_pt = np.sort(η_to_pt([0, η], esp/2))
plot_interval = [0.1, np.pi-.1]
#+end_src

#+RESULTS:

*** Analytical Integration
And now calculate the cross section in picobarn.
#+BEGIN_SRC jupyter-python :exports both :results raw file :file xs.tex
  xs_gev = total_xs_eta(η, charge, esp)
  xs_pb = gev_to_pb(xs_gev)
  tex_value(xs_pb, unit=r'\pico\barn', prefix=r'\sigma = ',
            prec=6, save=('results', 'xs.tex'))
#+END_SRC

#+RESULTS:
: \(\sigma = \SI{0.053793}{\pico\barn}\)

Lets plot the total xs as a function of η.
#+begin_src jupyter-python :exports both :results raw drawer
  fig, ax = set_up_plot()
  η_s = np.linspace(0, 3, 1000)
  ax.plot(η_s, gev_to_pb(total_xs_eta(η_s, charge, esp)))
  ax.set_xlabel(r'$\eta$')
  ax.set_ylabel(r'$\sigma$ [pb]')
  ax.set_xlim([0, max(η_s)])
  ax.set_ylim(0)
  save_fig(fig, 'total_xs', 'xs', size=[2.5, 2])
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/b709b22e5727fe27a94a18f9d31d40567f035376.png]]


Compared to sherpa, it's pretty close.
#+NAME: 81b5ed93-0312-45dc-beec-e2ba92e22626
#+BEGIN_SRC jupyter-python :exports both :results raw drawer
  sherpa = 0.05380
  xs_pb - sherpa
#+END_SRC

#+RESULTS: 81b5ed93-0312-45dc-beec-e2ba92e22626
: -6.7112594623469635e-06

I had to set the runcard option ~EW_SCHEME: alpha0~ to use the pure
QED coupling constant.

*** Numerical Integration
Plot our nice distribution:
#+begin_src jupyter-python :exports both :results raw drawer
plot_points = np.linspace(*plot_interval, 1000)

fig, ax = set_up_plot()
ax.plot(plot_points, gev_to_pb(diff_xs(plot_points, charge=charge, esp=esp)))
ax.set_xlabel(r'$\theta$')
ax.set_ylabel(r'$d\sigma/d\Omega$ [pb]')
ax.axvline(interval[0], color='gray', linestyle='--')
ax.axvline(interval[1], color='gray', linestyle='--', label=rf'$|\eta|={η}$')
ax.legend()
save_fig(fig, 'diff_xs', 'xs', size=[2.5, 2])
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/aa1aab15903411e94de8fd1d6f9b8c1de0e95b67.png]]

Define the integrand.
#+begin_src jupyter-python :exports both :results raw drawer
  def xs_pb_int(θ):
      return 2*np.pi*gev_to_pb(np.sin(θ)*diff_xs(θ, charge=charge, esp=esp))

  def xs_pb_int_η(η):
      return 2*np.pi*gev_to_pb(diff_xs_eta(η, charge, esp))
#+end_src

#+RESULTS:

Plot the integrand. # TODO: remove duplication
#+begin_src jupyter-python :exports both :results raw drawer
fig, ax = set_up_plot()
ax.plot(plot_points, xs_pb_int(plot_points))
ax.set_xlabel(r'$\theta$')
ax.set_ylabel(r'$\sin(\theta)\cdot\frac{d\sigma}{d\Omega}$ [pb]')
ax.axvline(interval[0], color='gray', linestyle='--')
ax.axvline(interval[1], color='gray', linestyle='--', label=rf'$|\eta|={η}$')
ax.legend()
save_fig(fig, 'xs_integrand', 'xs', size=[4, 4])
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/a84ac9746f0f4b0c2f1038dc249e557fc1fe48f5.png]]

Intergrate σ with the mc method.
#+begin_src jupyter-python :exports both :results raw drawer
  xs_pb_mc, xs_pb_mc_err = monte_carlo.integrate(xs_pb_int, interval, 1000)
  xs_pb_mc = xs_pb_mc
  xs_pb_mc, xs_pb_mc_err
#+end_src

#+RESULTS:
| 0.055441221086831506 | 0.0008656474309226884 |

We gonna export that as tex.
#+begin_src jupyter-python :exports both :results raw drawer
tex_value(xs_pb_mc, unit=r'\pico\barn', prefix=r'\sigma = ', err=xs_pb_mc_err, save=('results', 'xs_mc.tex'))
#+end_src

#+RESULTS:
: \(\sigma = \SI{0.0554\pm 0.0009}{\pico\barn}\)


Plot the intgrand of the pseudo rap.
#+begin_src jupyter-python :exports both :results raw drawer
fig, ax = set_up_plot()
points = np.linspace(*interval_η, 1000)
ax.plot(points, xs_pb_int_η(points))
ax.set_xlabel(r'$\eta$')
ax.set_ylabel(r'$\frac{d\sigma}{d\theta}$ [pb]')
save_fig(fig, 'xs_integrand_η', 'xs', size=[4, 4])
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/09de667c0ccb1d17fef74918e3f462a1340df113.png]]

As we see, the result is much better if we use pseudo rapidity,
because the differential cross section does not difverge anymore.
#+begin_src jupyter-python :exports both :results raw drawer
  xs_pb_η = monte_carlo.integrate(xs_pb_int_η,
                                  interval_η, 1000)
  xs_pb_η
#+end_src

#+RESULTS:
| 0.05367271529012346 | 0.00015819977327237987 |

And yet again export that as tex.
#+begin_src jupyter-python :exports both :results raw drawer
tex_value(*xs_pb_η, unit=r'\pico\barn', prefix=r'\sigma = ', save=('results', 'xs_mc_eta.tex'))
#+end_src

#+RESULTS:
: \(\sigma = \SI{0.05367\pm 0.00016}{\pico\barn}\)

Let's battle test the statistics.
#+begin_src jupyter-python :exports both :results raw drawer
  num_runs = 1000
  num_within = 0

  for _ in range(num_runs):
      val, err = monte_carlo.integrate(xs_pb_int_η, interval_η, 1000)
      if abs(xs_pb - val) <= err:
          num_within += 1

  num_within/num_runs
#+end_src

#+RESULTS:
: 0.674

So we see: the standard deviation is sound.

*** Sampling and Analysis
Define the sample number.
#+begin_src jupyter-python :exports both :results raw drawer
  sample_num = 1000
#+end_src

#+RESULTS:
Let's define shortcuts for our distributions. The 2π are just there
for formal correctnes. Factors do not influecence the outcome.
#+begin_src jupyter-python :exports both :results raw drawer
  def dist_θ(x):
      return gev_to_pb(diff_xs_cosθ(x, charge, esp))*2*np.pi

  def dist_η(x):
      return gev_to_pb(diff_xs_eta(x, charge, esp))*2*np.pi
#+end_src

#+RESULTS:

**** Sampling the cosθ cross section

Now we monte-carlo sample our distribution. We observe that the efficiency his very bad!
#+begin_src jupyter-python :exports both :results raw drawer
  cosθ_sample, cosθ_efficiency = \
      monte_carlo.sample_unweighted_array(sample_num, dist_θ,
                                          interval_cosθ, report_efficiency=True)
  cosθ_efficiency
#+end_src

#+RESULTS:
: 0.02705475753321093

Our distribution has a lot of variance, as can be seen by plotting it.
#+begin_src jupyter-python :exports both :results raw drawer
    pts = np.linspace(*interval_cosθ, 100)
    fig, ax = set_up_plot()
    ax.plot(pts, dist_θ(pts), label=r'$\frac{d\sigma}{d\Omega}$')
#+end_src

#+RESULTS:
:RESULTS:
| <matplotlib.lines.Line2D | at | 0x7ff6f9e629d0> |
[[file:./.ob-jupyter/04d0c9300d134c04b087aef7bb0a1b6036038b64.png]]
:END:

We define a friendly and easy to integrate upper limit function.
#+begin_src jupyter-python :exports both :results raw drawer
  upper_limit = dist_θ(interval_cosθ[0]) \
      /interval_cosθ[0]**2
  upper_base = dist_θ(0)

  def upper(x):
      return  upper_base + upper_limit*x**2

  def upper_int(x):
      return  upper_base*x + upper_limit*x**3/3

  ax.plot(pts, upper(pts), label='Upper bound')
  ax.legend()
  ax.set_xlabel(r'$\cos\theta$')
  ax.set_ylabel(r'$\frac{d\sigma}{d\Omega}$')
  save_fig(fig, 'upper_bound', 'xs_sampling', size=(4, 4))
  fig
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/1a720f93049e88987bdddac861b1c3847501e271.png]]


To increase our efficiency, we have to specify an upper bound. That is
at least a little bit better. The numeric inversion is horribly inefficent.
#+begin_src jupyter-python :exports both :results raw drawer
  cosθ_sample, cosθ_efficiency = \
      monte_carlo.sample_unweighted_array(sample_num, dist_θ,
                                          interval_cosθ, report_efficiency=True,
                                          upper_bound=[upper, upper_int])
  cosθ_efficiency
#+end_src

#+RESULTS:
: 0.07775726811259806

Nice! And now draw some histograms.

We define an auxilliary method for convenience.
#+begin_src jupyter-python :exports both :results raw drawer
  def draw_histo(points, xlabel, bins=20):
      heights, edges = np.histogram(points, bins)
      centers = (edges[1:] + edges[:-1])/2
      deviations = np.sqrt(heights)

      fig, ax = set_up_plot()
      ax.errorbar(centers, heights, deviations, linestyle='none', color='orange')
      ax.step(edges,  [heights[0], *heights], color='#1f77b4')

      ax.set_xlabel(xlabel)
      ax.set_xlim([points.min(), points.max()])
      return fig, ax
#+end_src

#+RESULTS:

The histogram for cosθ.
#+begin_src jupyter-python :exports both :results raw drawer
fig, _ = draw_histo(cosθ_sample, r'$\cos\theta$')
save_fig(fig, 'histo_cos_theta', 'xs', size=(4,3))
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/62a29c0e9910c0c3a52db2d94943811f956af818.png]]

**** Observables
Now we define some utilities to draw real 4-momentum samples.
#+begin_src jupyter-python :exports both :tangle tangled/xs.py
  def sample_momenta(sample_num, interval, charge, esp, seed=None):
      """Samples `sample_num` unweighted photon 4-momenta from the
      cross-section.

      :param sample_num: number of samples to take
      :param interval: cosθ interval to sample from
      :param charge: the charge of the quark
      :param esp: center of mass energy
      :param seed: the seed for the rng, optional, default is system
          time

      :returns: an array of 4 photon momenta

      :rtype: np.ndarray
      """
      cosθ_sample = \
          monte_carlo.sample_unweighted_array(sample_num,
                                              lambda x:
                                                diff_xs_cosθ(x, charge, esp),
                                             interval_cosθ)
      φ_sample = np.random.uniform(0, 1, sample_num)

      def make_momentum(esp, cosθ, φ):
          sinθ = np.sqrt(1-cosθ**2)
          return np.array([1, sinθ*np.cos(φ), sinθ*np.sin(φ), cosθ])*esp/2

      momenta = np.array([make_momentum(esp, cosθ, φ) \
                           for cosθ, φ in np.array([cosθ_sample, φ_sample]).T])
      return momenta
#+end_src

#+RESULTS:

To generate histograms of other obeservables, we have to define them
as functions on 4-impuleses. Using those to transform samples is
analogous to transforming the distribution itself.
#+begin_src jupyter-python :exports both :results raw drawer :tangle tangled/observables.py
  """This module defines some observables on arrays of 4-pulses."""
  import numpy as np

  def p_t(p):
      """Transverse momentum

      :param p: array of 4-momenta
      """

      return np.linalg.norm(p[:,1:3], axis=1)

  def η(p):
      """Pseudo rapidity.

      :param p: array of 4-momenta
      """

      return np.arccosh(np.linalg.norm(p[:,1:], axis=1)/p_t(p))*np.sign(p[:, 3])
#+end_src

#+RESULTS:


Lets try it out.
#+begin_src jupyter-python :exports both :results raw drawer
  momentum_sample = sample_momenta(2000, interval_cosθ, charge, esp)
  momentum_sample
#+end_src

#+RESULTS:
: array([[100.        ,  47.18813066,  20.64234473, -85.71565743],
:        [100.        ,  15.71929112,  11.95618298, -98.03037068],
:        [100.        ,  74.89660507,  59.11115883, -29.9394297 ],
:        ...,
:        [100.        ,  19.29194247,   7.026877  ,  97.86952516],
:        [100.        ,  79.11073693,  55.29696215,  26.1483705 ],
:        [100.        ,  26.68616492,  13.46194026,  95.42863704]])

Now let's make a histogram of the η distribution.
#+begin_src jupyter-python :exports both :results raw drawer
  η_sample = η(momentum_sample)
  draw_histo(η_sample, r'$\eta$')
#+end_src

#+RESULTS:
:RESULTS:
| <Figure | size | 432x288 | with | 1 | Axes> | <matplotlib.axes._subplots.AxesSubplot | at | 0x7ff6fb53b0d0> |
[[file:./.ob-jupyter/13665238c516fd85aee4cf3d84017a3edefad70f.png]]
:END:


And the same for the p_t (transverse momentum) distribution.
#+begin_src jupyter-python :exports both :results raw drawer
  p_t_sample = p_t(momentum_sample)
  draw_histo(p_t_sample, r'$p_T$ [GeV]')
#+end_src

#+RESULTS:
:RESULTS:
| <Figure | size | 432x288 | with | 1 | Axes> | <matplotlib.axes._subplots.AxesSubplot | at | 0x7ff6fb5d23d0> |
[[file:./.ob-jupyter/f1fe0ff3ce1e84dcde0355e1ebec7a39a09fd603.png]]
:END:

That looks somewhat fishy, but it isn't.
#+begin_src jupyter-python :exports both :results raw drawer
  fig, ax = set_up_plot()
  points = np.linspace(interval_pt[0], interval_pt[1] - .01, 1000)
  ax.plot(points, gev_to_pb(diff_xs_p_t(points, charge, esp)))
  ax.set_xlabel(r'$p_T$')
  ax.set_xlim(interval_pt[0], interval_pt[1] + 1)
  ax.set_ylim([0, gev_to_pb(diff_xs_p_t(interval_pt[1] -.01, charge, esp))])
  ax.set_ylabel(r'$\frac{d\sigma}{dp_t}$ [pb]')
  save_fig(fig, 'diff_xs_p_t', 'xs_sampling', size=[4, 3])
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/739fdde6357d58890ef7847d0afc3277cffa9062.png]]
this is strongly peaked at p_t=100GeV. (The jacobian goes like 1/x there!)

**** Sampling the η cross section
An again we see that the efficiency is way, way! better...
#+begin_src jupyter-python :exports both :results raw drawer
  η_sample, η_efficiency = \
      monte_carlo.sample_unweighted_array(sample_num, dist_η,
                                          interval_η, report_efficiency=True)
  η_efficiency
#+end_src

#+RESULTS:
: 0.4033333333333333

Let's draw a histogram to compare with the previous results.
#+begin_src jupyter-python :exports both :results raw drawer
  draw_histo(η_sample, r'$\eta$')
#+end_src

#+RESULTS:
:RESULTS:
| <Figure | size | 432x288 | with | 1 | Axes> | <matplotlib.axes._subplots.AxesSubplot | at | 0x7ff6f9c27a00> |
[[file:./.ob-jupyter/08043c8f8e6f6981439dda8072b6e538f2f02e73.png]]
:END:
Looks good to me :).
