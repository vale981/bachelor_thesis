#+PROPERTY: header-args :exports both :output-dir results :session xs :kernel python3
#+TITLE: Investigaton of Monte-Carlo Methods
#+AUTHOR: Valentin Boettcher

* Init
** Required Modules
#+NAME: e988e3f2-ad1f-49a3-ad60-bedba3863283
#+begin_src jupyter-python :exports both :tangle tangled/xs.py
  import numpy as np
  import matplotlib.pyplot as plt
  import monte_carlo
#+end_src

#+RESULTS: e988e3f2-ad1f-49a3-ad60-bedba3863283

** Utilities
#+NAME: 53548778-a4c1-461a-9b1f-0f401df12b08
#+BEGIN_SRC jupyter-python :exports both
%run ../utility.py
%load_ext autoreload
%aimport monte_carlo
%autoreload 1
#+END_SRC

#+RESULTS: 53548778-a4c1-461a-9b1f-0f401df12b08
: The autoreload extension is already loaded. To reload it, use:
:   %reload_ext autoreload

* Implementation
** Center of Mass Frame
#+NAME: 777a013b-6c20-44bd-b58b-6a7690c21c0e
#+BEGIN_SRC jupyter-python :exports both :results raw drawer :exports code :tangle tangled/xs.py
  """
  Implementation of the analytical cross section for q q_bar ->
  gamma gamma

  Author: Valentin Boettcher <hiro@protagon.space>
  """

  import numpy as np

  # NOTE: a more elegant solution would be a decorator
  def energy_factor(charge, esp):
      """
      Calculates the factor common to all other values in this module

      Arguments:
      esp -- center of momentum energy in GeV
      charge -- charge of the particle in units of the elementary charge
      """

      return charge ** 4 / (137.036 * esp) ** 2 / 6


  def diff_xs(θ, charge, esp):
      """
      Calculates the differential cross section as a function of the
      azimuth angle θ in units of 1/GeV².

      Here dΩ=sinθdθdφ

      Arguments:
      θ -- azimuth angle
      esp -- center of momentum energy in GeV
      charge -- charge of the particle in units of the elementary charge
      """

      f = energy_factor(charge, esp)
      return f * ((np.cos(θ) ** 2 + 1) / np.sin(θ) ** 2)


  def diff_xs_cosθ(cosθ, charge, esp):
      """
      Calculates the differential cross section as a function of the
      cosine of the azimuth angle θ in units of 1/GeV².

      Here dΩ=d(cosθ)dφ

      Arguments:
      cosθ -- cosine of the azimuth angle
      esp -- center of momentum energy in GeV
      charge -- charge of the particle in units of the elementary charge
      """

      f = energy_factor(charge, esp)
      return f * ((cosθ ** 2 + 1) / (1 - cosθ ** 2))


  def diff_xs_eta(η, charge, esp):
      """
      Calculates the differential cross section as a function of the
      pseudo rapidity of the photons in units of 1/GeV^2.

      This is actually the crossection dσ/(dφdη).

      Arguments:
      η -- pseudo rapidity
      esp -- center of momentum energy in GeV
      charge -- charge of the particle in units of the elementary charge
      """

      f = energy_factor(charge, esp)
      return f * (np.tanh(η) ** 2 + 1)


  def diff_xs_p_t(p_t, charge, esp):
      """
      Calculates the differential cross section as a function of the
      transverse momentum (p_t) of the photons in units of 1/GeV^2.

      This is actually the crossection dσ/(dφdp_t).

      Arguments:
      p_t -- transverse momentum in GeV
      esp -- center of momentum energy in GeV
      charge -- charge of the particle in units of the elementary charge
      """

      f = energy_factor(charge, esp)
      sqrt_fact = np.sqrt(1 - (2 * p_t / esp) ** 2)
      return f / p_t * (1 / sqrt_fact + sqrt_fact)


  def total_xs_eta(η, charge, esp):
      """
      Calculates the total cross section as a function of the pseudo
      rapidity of the photons in units of 1/GeV^2.  If the rapditiy is
      specified as a tuple, it is interpreted as an interval.  Otherwise
      the interval [-η, η] will be used.

      Arguments:
      η -- pseudo rapidity (tuple or number)
      esp -- center of momentum energy in GeV
      charge -- charge of the particle in units of the elementar charge
      """

      f = energy_factor(charge, esp)
      if not isinstance(η, tuple):
          η = (-η, η)

      if len(η) != 2:
          raise ValueError("Invalid η cut.")

      def F(x):
          return np.tanh(x) - 2 * x

      return 2 * np.pi * f * (F(η[0]) - F(η[1]))
#+END_SRC

#+RESULTS: 777a013b-6c20-44bd-b58b-6a7690c21c0e
* Calculations
First, set up the input parameters.
#+BEGIN_SRC jupyter-python :exports both :results raw drawer
η = 2.5
charge = 1/3
esp = 200  # GeV
#+END_SRC

#+RESULTS:

Let's save that stuff.
#+begin_src jupyter-python :exports both :results raw drawer
  tex_value(η, prefix=r"\abs{\eta}\leq ", prec=1, save=("results", "eta.tex"))
  tex_value(
      esp, prefix=r"\ecm = ", unit=r"\giga\electronvolt", save=("results", "ecm.tex")
  )
#+end_src


#+RESULTS:
: \(\ecm = \SI{200}{\giga\electronvolt}\)

Set up the integration and plot intervals.
#+begin_src jupyter-python :exports both :results raw drawer
interval_η = [-η, η]
interval = η_to_θ([-η, η])
interval_cosθ = np.cos(interval)
interval_pt = np.sort(η_to_pt([0, η], esp/2))
#+end_src

#+RESULTS:

#+begin_note
Note that we could utilize the symetry of the integrand throughout,
but that doen't reduce variance and would complicate things now.
#+end_note

** Analytical Integration
Let's plot a more detailed view of the xs.
#+begin_src jupyter-python :exports both :results raw drawer
  plot_points = np.linspace(np.pi/2 - 0.5, np.pi/2 + 0.5, 1000)
  plot_points = plot_points[plot_points > 0]

  fig, ax = set_up_plot()
  ax.plot(plot_points, gev_to_pb(diff_xs(plot_points, charge=charge, esp=esp)))
  ax.set_xlabel(r"$\theta$")
  ax.set_ylabel(r"$\mathrm{d}\sigma/\mathrm{d}\Omega$ [pb]")
  ax.set_xlim([plot_points.min(), plot_points.max()])
  save_fig(fig, "diff_xs_zoom", "xs", size=[2.5, 2.5])
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/7466ab6e4dd5f81d66dae2e1ba4531efa6885336.png]]

 And now calculate the cross section in picobarn.
 #+BEGIN_SRC jupyter-python :exports both :results raw file :file xs.tex
   xs_gev = total_xs_eta(η, charge, esp)
   xs_pb = gev_to_pb(xs_gev)
   tex_value(xs_pb, unit=r'\pico\barn', prefix=r'\sigma = ',
             prec=6, save=('results', 'xs.tex'))
 #+END_SRC

 #+RESULTS:
 : \(\sigma = \SI{0.053793}{\pico\barn}\)

 Lets plot the total xs as a function of η.
 #+begin_src jupyter-python :exports both :results raw drawer
   fig, ax = set_up_plot()
   η_s = np.linspace(0, 3, 1000)
   ax.plot(η_s, gev_to_pb(total_xs_eta(η_s, charge, esp)))
   ax.set_xlabel(r'$\eta$')
   ax.set_ylabel(r'$\sigma$ [pb]')
   ax.set_xlim([0, max(η_s)])
   ax.set_ylim(0)
   save_fig(fig, 'total_xs', 'xs', size=[2.5, 2.5])
 #+end_src

 #+RESULTS:
 [[file:./.ob-jupyter/4522eb3fbeaa14978f9838371acb0650910b8dbf.png]]


 Compared to sherpa, it's pretty close.
 #+NAME: 81b5ed93-0312-45dc-beec-e2ba92e22626
 #+BEGIN_SRC jupyter-python :exports both :results raw drawer
   sherpa = np.loadtxt("../../runcards/qqgg/sherpa_xs", delimiter=",")
   tex_value(
       ,*sherpa, unit=r"\pico\barn", prefix=r"\sigma = ", prec=6, save=("results", "xs_sherpa.tex")
   )
   xs_pb - sherpa[0]
 #+END_SRC

 #+RESULTS: 81b5ed93-0312-45dc-beec-e2ba92e22626
 : -5.112594623490896e-07

 I had to set the runcard option ~EW_SCHEME: alpha0~ to use the pure
 QED coupling constant.

** Numerical Integration
Plot our nice distribution:
#+begin_src jupyter-python :exports both :results raw drawer
  plot_points = np.linspace(*np.arccos(interval_cosθ), 1000)
  plot_points = plot_points[plot_points > 0]

  fig, ax = set_up_plot()
  ax.plot(plot_points, gev_to_pb(diff_xs(plot_points, charge=charge, esp=esp)))
  ax.set_xlabel(r'$\theta$')
  ax.set_ylabel(r'$\mathrm{d}\sigma/\mathrm{d}\Omega$ [pb]')
  ax.set_xlim([plot_points.min(), plot_points.max()])
  save_fig(fig, 'diff_xs', 'xs', size=[2.5, 2.5])
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/37306932df4d28e56eff37c1b1dbe5efcf5f38c5.png]]

Define the integrand.
#+begin_src jupyter-python :exports both :results raw drawer
  def xs_pb_int(θ):
      return 2*np.pi*gev_to_pb(np.sin(θ)*diff_xs(θ, charge=charge, esp=esp))

  def xs_pb_int_η(η):
      return 2*np.pi*gev_to_pb(diff_xs_eta(η, charge, esp))
#+end_src

#+RESULTS:

Plot the integrand. # TODO: remove duplication
#+begin_src jupyter-python :exports both :results raw drawer
  fig, ax = set_up_plot()
  plot_points = np.linspace(*interval, 100)
  vals = xs_pb_int(plot_points)
  ax.plot(plot_points, xs_pb_int(plot_points))
  ax.set_xlabel(r"$\theta$")
  ax.set_ylabel(r"$2\pi\cdot \mathrm{d}\sigma/\mathrm{d}\theta$ [pb]")
  ax.set_xlim([plot_points.min(), plot_points.max()])
  ax.axhline(vals.mean(), color="gray", linestyle="--", label="mean")
  ax.axhspan(
      vals.mean() - vals.std(),
      vals.mean() + vals.std(),
      alpha=0.1,
      color="red",
      label=r"$\sigma$",
  )
  ax.legend()
  ax.set_ylim([0, 0.09])
  save_fig(fig, "xs_integrand", "xs", size=[3, 2.2])
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/ae89081fd4dc96b3851ae0ed83ef1a8bf24957a3.png]]
*** Integral over θ
Intergrate σ with the mc method.
#+begin_src jupyter-python :exports both :results raw drawer
  xs_pb_res = monte_carlo.integrate(xs_pb_int, interval, epsilon=1e-3)
  xs_pb_res
#+end_src

#+RESULTS:
: IntegrationResult(result=0.05404067829354404, sigma=0.0009555507112178561, N=2042)

We gonna export that as tex.
#+begin_src jupyter-python :exports both :results raw drawer
  tex_value(*xs_pb_res.combined_result, unit=r'\pico\barn',
            prefix=r'\sigma = ', save=('results', 'xs_mc.tex'))
  tex_value(xs_pb_res.N, prefix=r'N = ', save=('results', 'xs_mc_N.tex'))
#+end_src

#+RESULTS:
: \(N = 2042\)

*** Integration over η
Plot the intgrand of the pseudo rap.
#+begin_src jupyter-python :exports both :results raw drawer
  fig, ax = set_up_plot()
  points = np.linspace(*interval_η, 1000)
  ax.set_xlim(*interval_η)
  vals = xs_pb_int_η(points)
  ax.plot(points, vals)
  ax.set_xlabel(r"$\eta$")
  ax.set_ylabel(r"$2\pi\cdot \mathrm{d}\sigma/\mathrm{d}\eta$ [pb]")
  ax.axhline(vals.mean(), color="gray", linestyle="--", label="mean")
  ax.axhspan(
      vals.mean() - vals.std(),
      vals.mean() + vals.std(),
      alpha=0.1,
      color="red",
      label=r"$\sigma$",
  )
  ax.legend()
  ax.set_ylim([0, 0.09])
  save_fig(fig, "xs_integrand_eta", "xs", size=[3, 2.2])
  vals.std()
#+end_src

#+RESULTS:
:RESULTS:
: 0.0022315324126441238
[[file:./.ob-jupyter/df9765373fa441d9bd5b8c72e4570b6e57a4efd1.png]]
:END:

#+begin_src jupyter-python :exports both :results raw drawer
  xs_pb_η = monte_carlo.integrate(xs_pb_int_η,
                                  interval_η, epsilon=1e-3)
  xs_pb_η
#+end_src

#+RESULTS:
: IntegrationResult(result=0.0539225823635837, sigma=0.0009726447951613801, N=129)

As we see, the result is a little better if we use pseudo rapidity,
because the differential cross section does not difverge anymore.  But
becase our η interval is covering the range where all the variance is
occuring, the improvement is rather marginal.

And yet again export that as tex.
#+begin_src jupyter-python :exports both :results raw drawer
  tex_value(*xs_pb_η.combined_result, unit=r'\pico\barn', prefix=r'\sigma = ',
            save=('results', 'xs_mc_eta.tex'))
  tex_value(xs_pb_η.N, prefix=r'N = ', save=('results', 'xs_mc_eta_N.tex'))
#+end_src

#+RESULTS:
: \(N = 129\)

*** Using =VEGAS=
Now we use =VEGAS= on the θ parametrisation and see what happens.
#+begin_src jupyter-python :exports both :results raw drawer
  num_increments = 20
  xs_pb_vegas = monte_carlo.integrate_vegas(
      xs_pb_int,
      interval,
      num_increments=num_increments,
      alpha=2,
      increment_epsilon=0.02,
      vegas_point_density=20,
      epsilon=.001,
      acumulate=False,
  )
  xs_pb_vegas
#+end_src

#+RESULTS:
: VegasIntegrationResult(result=0.055228064564004795, sigma=0.0007080815177218788, N=280, increment_borders=array([0.16380276, 0.20233559, 0.2483101 , 0.30892526, 0.38540143,
:        0.48404666, 0.61040504, 0.77646193, 0.99569736, 1.28300786,
:        1.62098314, 1.94122381, 2.19922166, 2.39276424, 2.54204101,
:        2.65643191, 2.75079333, 2.82673522, 2.88773282, 2.93692007,
:        2.9777899 ]), vegas_iterations=7)

This is pretty good, although the variance reduction may be achieved
partially by accumulating the results from all runns. Here this gives
us one order of magnitude more than we wanted.

And export that as tex.
#+begin_src jupyter-python :exports both :results raw drawer
  tex_value(*xs_pb_vegas.combined_result, unit=r'\pico\barn',
            prefix=r'\sigma = ', save=('results', 'xs_mc_θ_vegas.tex'))
  tex_value(xs_pb_vegas.N, prefix=r'N = ', save=('results', 'xs_mc_θ_vegas_N.tex'))
  tex_value(xs_pb_vegas.vegas_iterations, prefix=r'\times', save=('results', 'xs_mc_θ_vegas_it.tex'))
  tex_value(num_increments, prefix=r'K = ', save=('results', 'xs_mc_θ_vegas_K.tex'))
#+end_src

#+RESULTS:
: \(K = 20\)

Surprisingly, acumulation, the result ain't much different.
This depends, of course, on the iteration count.
#+begin_src jupyter-python :exports both :results raw drawer
  monte_carlo.integrate_vegas(
      xs_pb_int,
      interval,
      num_increments=num_increments,
      alpha=2,
      increment_epsilon=0.02,
      vegas_point_density=20,
      epsilon=.001,
      acumulate=True,
  )
#+end_src

#+RESULTS:
: VegasIntegrationResult(result=0.05324756245499766, sigma=0.0004329603286199391, N=280, increment_borders=array([0.16380276, 0.20604579, 0.25571171, 0.31360373, 0.38994537,
:        0.48567316, 0.60719424, 0.75914834, 0.96094206, 1.23541039,
:        1.57009106, 1.90475795, 2.18153577, 2.38026918, 2.53394687,
:        2.65380143, 2.74689675, 2.82228553, 2.88410754, 2.93498124,
:        2.9777899 ]), vegas_iterations=7)

Let's define some little helpers.
#+begin_src jupyter-python :exports both :tangle tangled/plot_utils.py
  """
  Some shorthands for common plotting tasks related to the investigation
  of monte-carlo methods in one rimension.

  Author: Valentin Boettcher <hiro at protagon.space>
  """

  import matplotlib.pyplot as plt
  import numpy as np
  from utility import *


  def plot_increments(ax, increment_borders, label=None, *args, **kwargs):
      """Plot the increment borders from a list.  The first and last one

      :param ax: the axis on which to draw
      :param list increment_borders: the borders of the increments
      :param str label: the label to apply to one of the vertical lines
      """

      ax.axvline(x=increment_borders[1], label=label, *args, **kwargs)

      for increment in increment_borders[1:-1]:
          ax.axvline(x=increment, *args, **kwargs)


  def plot_vegas_weighted_distribution(
      ax, points, dist, increment_borders, integral=None, color="orange", *args, **kwargs
  ):
      """Plot the distribution with VEGAS weights applied.

      :param ax: axis
      :param points: points
      :param dist: distribution
      :param increment_borders: increment borders
      """

      num_increments = increment_borders.size
      weighted_dist = dist.copy()

      var = 0
      total_weight = points.max() - points.min()
      for left_border, right_border in zip(increment_borders[:-1], increment_borders[1:]):
          length = right_border - left_border
          mask = (left_border <= points) & (points <= right_border)
          weighted_dist[mask] = dist[mask] * num_increments * length
          if integral:
              var += (
                  np.sum((integral - weighted_dist[mask]) ** 2)
                  / (weighted_dist[mask].size - 1)
                  ,* length
                  / total_weight
              )

      if integral:
          std = np.sqrt(var)
          ax.axhline(weighted_dist.mean(), color=color, linestyle="--")
          ax.axhspan(
              weighted_dist.mean() - std,
              weighted_dist.mean() + std,
              color=color,
              alpha=0.2,
              linestyle="--",
          )

      ax.plot(
          points, weighted_dist, *args, color=color, **kwargs,
      )


  def plot_stratified_rho(ax, points, increment_borders, *args, **kwargs):
      """Plot the weighting distribution resulting from the increment
      borders.

      :param ax: axis
      :param points: points
      :param increment_borders: increment borders

      """

      num_increments = increment_borders.size
      ρ = np.empty_like(points)
      for left_border, right_border in zip(increment_borders[:-1], increment_borders[1:]):
          length = right_border - left_border
          mask = (left_border <= points) & (points <= right_border)
          ρ[mask] = 1 / (num_increments * length)

      ax.plot(points, ρ, *args, **kwargs)
#+end_src

#+RESULTS:

And now we plot the integrand with the incremens.
#+begin_src jupyter-python :exports both :results raw drawer
  fig, ax = set_up_plot()
  ax.set_xlim(*interval)
  ax.set_xlabel(r"$\theta$")
  ax.set_ylabel(r"$2\pi\cdot \mathrm{d}\sigma/\mathrm{d}\theta$ [pb]")
  ax.set_ylim([0, 0.09])
  plot_points = np.linspace(*interval, 1000)
  vals = xs_pb_int(plot_points)
  ax.plot(plot_points, xs_pb_int(plot_points), label="Distribution")
  ax.axhline(vals.mean(), color="C0", linestyle="--")
  ax.axhspan(
      vals.mean() - vals.std(),
      vals.mean() + vals.std(),
      alpha=0.1,
      color="C0",
  )

  plot_increments(
      ax,
      xs_pb_vegas.increment_borders,
      label="Increment Borders",
      color="gray",
      linestyle="--",
  )

  plot_vegas_weighted_distribution(
      ax,
      plot_points,
      xs_pb_int(plot_points),
      xs_pb_vegas.increment_borders,
      xs_pb_vegas.result,
      label="Weighted Distribution",
  )

  ax.legend(fontsize="small", loc="lower left")
  save_fig(fig, "xs_integrand_vegas", "xs", size=[5, 3])
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/b8300645a28ff7d6830df60fd0044ee5ce5c5415.png]]
*** Testing the Statistics
Let's battle test the statistics.
#+begin_src jupyter-python :exports both :results raw drawer
  num_runs = 1000
  num_within = 0

  for _ in range(num_runs):
      val, err = \
          monte_carlo.integrate(xs_pb_int, interval, epsilon=1e-3).combined_result
      if abs(xs_pb - val) <= err:
          num_within += 1

  num_within/num_runs
#+end_src

#+RESULTS:
: 0.677

So we see: the standard deviation is sound.

Doing the same thing with =VEGAS= works as well.
#+begin_src jupyter-python :exports both :results raw drawer
  num_runs = 1000
  num_within = 0
  for _ in range(num_runs):
      val, err = monte_carlo.integrate_vegas(
          xs_pb_int,
          interval,
          num_increments=num_increments,
          alpha=1,
          increment_epsilon=0.02,
          vegas_point_density=10,
          epsilon=0.1,
          acumulate=False,
      ).combined_result

      if abs(xs_pb - val) <= err:
          num_within += 1
  num_within / num_runs
#+end_src

#+RESULTS:
:RESULTS:
: /home/hiro/Documents/Projects/UNI/Bachelor/prog/python/qqgg/monte_carlo.py:451: RuntimeWarning: invalid value encountered in double_scalars
:   variance = (
: 0.0
:END:

** Sampling and Analysis
Define the sample number.
#+begin_src jupyter-python :exports both :results raw drawer
  sample_num = 1_000_000
  tex_value(
      sample_num, prefix="N = ", save=("results", "4imp-sample-size.tex"),
  )
#+end_src

#+RESULTS:
: \(N = 1000000\)

Let's define shortcuts for our distributions. The 2π are just there
for formal correctnes. Factors do not influecence the outcome.
#+begin_src jupyter-python :exports both :results raw drawer
  def dist_cosθ(x):
      return gev_to_pb(diff_xs_cosθ(x, charge, esp))

  def dist_η(x):
      return gev_to_pb(diff_xs_eta(x, charge, esp))
#+end_src

#+RESULTS:

*** Sampling the cosθ cross section

Now we monte-carlo sample our distribution. We observe that the efficiency his very bad!
#+begin_src jupyter-python :exports both :results raw drawer
  cosθ_sample, cosθ_efficiency = \
      monte_carlo.sample_unweighted_array(sample_num, dist_cosθ,
                                          interval_cosθ, report_efficiency=True,
                                          cache='cache/bare_cos_theta',
                                          proc='auto')
  cosθ_efficiency
#+end_src

#+RESULTS:
:RESULTS:
: Loading Cache:  sample_unweighted_array
: 0.02738751517805198
:END:

Let's save that.
#+begin_src jupyter-python :exports both :results raw drawer
  tex_value(
      cosθ_efficiency * 100,
      prefix=r"\mathfrak{e} = ",
      suffix=r"\%",
      save=("results", "naive_th_samp.tex"),
  )
#+end_src

#+RESULTS:
: \(\mathfrak{e} = 3\%\)

Our distribution has a lot of variance, as can be seen by plotting it.
#+begin_src jupyter-python :exports both :results raw drawer
  pts = np.linspace(*interval_cosθ, 100)
  fig, ax = set_up_plot()
  ax.plot(pts, dist_cosθ(pts))
  ax.set_xlabel(r'$\cos\theta$')
  ax.set_ylabel(r'$\frac{\mathrm{d}\sigma}{\mathrm{d}\Omega}$')
#+end_src

#+RESULTS:
:RESULTS:
: Text(0, 0.5, '$\\frac{\mathrm{d}\\sigma}{\mathrm{d}\\Omega}$')
[[file:./.ob-jupyter/a9e1c809c0f72c09ab5e91022ecd407fcc833d95.png]]
:END:

We define a friendly and easy to integrate upper limit function.
#+begin_src jupyter-python :exports both :results raw drawer
  fig, ax = set_up_plot()
  upper_limit = dist_cosθ(interval_cosθ[0]) / interval_cosθ[0] ** 2
  upper_base = dist_cosθ(0)


  def upper(x):
      return upper_base + upper_limit * x ** 2


  def upper_int(x):
      return upper_base * x + upper_limit * x ** 3 / 3


  ax.plot(pts, upper(pts), label="upper bound")
  ax.plot(pts, dist_cosθ(pts), label=r"$f_{\cos\theta}$")

  ax.legend(fontsize='small')
  ax.set_xlabel(r"$\cos\theta$")
  ax.set_ylabel(r"$\frac{\mathrm{d}\sigma}{\mathrm{d}\cos\theta}$ [pb]")
  save_fig(fig, "upper_bound", "xs_sampling", size=(3, 2.5))
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/d5f9e5a84f6ec36d0bca418a3a42ff283f6e45c8.png]]


To increase our efficiency, we have to specify an upper bound. That is
at least a little bit better. The numeric inversion is horribly inefficent.
#+begin_src jupyter-python :exports both :results raw drawer
  cosθ_sample_tuned, cosθ_efficiency_tuned = monte_carlo.sample_unweighted_array(
      sample_num,
      dist_cosθ,
      interval_cosθ,
      report_efficiency=True,
      proc="auto",
      cache="cache/bare_cos_theta_tuned",
      upper_bound=[upper, upper_int],
  )
  cosθ_efficiency_tuned
#+end_src

#+RESULTS:
:RESULTS:
: Loading Cache:  sample_unweighted_array
: 0.07904706665774734
:END:
<<cosθ-bare-eff>>

#+begin_src jupyter-python :exports both :results raw drawer
  tex_value(
      cosθ_efficiency_tuned * 100,
      prefix=r"\mathfrak{e} = ",
      suffix=r"\%",
      save=("results", "tuned_th_samp.tex"),
  )
#+end_src

#+RESULTS:
: \(\mathfrak{e} = 8\%\)

# TODO: Looks fishy
Nice! And now draw some histograms.

We define an auxilliary method for convenience.
#+begin_src jupyter-python :exports both :results raw drawer :tangle tangled/plot_utils.py
  import matplotlib.gridspec as gridspec


  def test_compatibility(hist_1, hist_2, confidence=1):
      mask = hist_1 > hist_2
      comp_greater = hist_1[mask] - confidence * np.sqrt(hist_1[mask]) <= hist_2[
          mask
      ] + confidence * np.sqrt(hist_2[mask])
      comp_lower = hist_1[~mask] + confidence * np.sqrt(hist_1[~mask]) >= hist_2[
          ~mask
      ] - confidence * np.sqrt(hist_2[~mask])

      return (np.count_nonzero(comp_greater) + np.count_nonzero(comp_lower)) / len(hist_1)


  def draw_ratio_plot(histograms, normalize_to=1, **kwargs):
      fig, (ax_hist, ax_ratio) = set_up_plot(
          2, 1, sharex=True, gridspec_kw=dict(height_ratios=[3, 1], hspace=0), **kwargs
      )

      reference, edges = histograms[0]["hist"]
      reference_error = np.sqrt(reference)

      ref_int = hist_integral(histograms[0]["hist"])
      reference = reference / ref_int
      reference_error = reference_error / ref_int

      for histogram in histograms:
          heights, _ = (
              histogram["hist"]
              if "hist" in histogram
              else np.histogram(histogram["samples"], bins=edges)
          )
          print(test_compatibility(heights, histograms[0]["hist"][0]))

          integral = hist_integral([heights, edges])
          errors = np.sqrt(heights) / integral
          heights = heights / integral

          draw_histogram(
              ax_hist,
              [heights, edges],
              errorbars=errors,
              hist_kwargs=(
                  histogram["hist_kwargs"] if "hist_kwargs" in histogram else dict()
              ),
              errorbar_kwargs=(
                  histogram["errorbar_kwargs"]
                  if "errorbar_kwargs" in histogram
                  else dict()
              ),
              normalize_to=normalize_to,
          )

          set_up_axis(ax_ratio, pimp_top=False)
          draw_histogram(
              ax_ratio,
              [
                  np.divide(
                      heights, reference, out=np.ones_like(heights), where=reference != 0
                  ),
                  edges,
              ],
              errorbars=np.divide(
                  errors, reference, out=np.zeros_like(heights), where=reference != 0
              ),
              hist_kwargs=(
                  histogram["hist_kwargs"] if "hist_kwargs" in histogram else dict()
              ),
              errorbar_kwargs=(
                  histogram["errorbar_kwargs"]
                  if "errorbar_kwargs" in histogram
                  else dict()
              ),
              normalize_to=None,
          )

          ax_ratio.set_ylabel("ratio")

      return fig, (ax_hist, ax_ratio)


  def hist_integral(hist):
      heights, edges = hist
      return heights @ (edges[1:] - edges[:-1])


  def draw_histogram(
      ax,
      histogram,
      errorbars=True,
      hist_kwargs=dict(color="#1f77b4"),
      errorbar_kwargs=dict(),
      autoau=True,
      normalize_to=None,
  ):
      """Draws a histogram with optional errorbars using the step style.

      :param ax: axis to draw on
      :param histogram: an array of the form [heights, edges]
      :param hist_kwargs: keyword args to pass to `ax.step`
      :param errorbar_kwargs: keyword args to pass to `ax.errorbar`
      :param autoau: if set, the y axis will receive an a.u. label
      :param normalize_to: if set, the histogram will be normalized to the value
      :returns: the given axis
      """

      heights, edges = histogram
      centers = (edges[1:] + edges[:-1]) / 2
      deviations = (
          (errorbars if isinstance(errorbars, (np.ndarray, list)) else np.sqrt(heights))
          if errorbars is not False
          else None
      )

      if normalize_to is not None:
          integral = hist_integral(histogram)
          heights = heights / integral * normalize_to
          if errorbars is not False:
              deviations = deviations / integral * normalize_to

      hist_plot = ax.step(edges, [heights[0], *heights], **hist_kwargs)

      if errorbars is not False:
          if "color" not in errorbar_kwargs:
              errorbar_kwargs["color"] = hist_plot[0].get_color()

          ax.errorbar(centers, heights, deviations, linestyle="none", **errorbar_kwargs)

      ax.set_xlim(*[edges[0], edges[-1]])
      ax.set_ylabel("a.u.")

      return ax


  def draw_histo_auto(points, xlabel, bins=50, range=None, rethist=False, **kwargs):
      """Creates a histogram figure from sample points, normalized to unity.

      :param points: samples
      :param xlabel: label of the x axis
      :param bins: number of bins
      :param range: the range of the values
      :param rethist: whether to return the histogram as third argument
      :returns: figure, axis
      """

      hist = np.histogram(points, bins, range=range, **kwargs)
      fig, ax = set_up_plot()
      draw_histogram(ax, hist, normalize_to=1)

      ax.set_xlabel(xlabel)
      ax.set_ylabel("Count")

      return (fig, ax, hist) if rethist else (fig, ax)
#+end_src

#+RESULTS:

The histogram for cosθ.
#+begin_src jupyter-python :exports both :results raw drawer
  fig, _ = draw_histo_auto(cosθ_sample, r'$\cos\theta$')
  save_fig(fig, 'histo_cos_theta', 'xs', size=(4,3))
  hist_cosθ = np.histogram(cosθ_sample, bins=50, range=interval_cosθ)
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/ebc5d8873924ff1b194ac2855e0c701a67359392.png]]

*** Observables
Now we define some utilities to draw real 4-momentum samples.
#+begin_src jupyter-python :exports both :tangle tangled/xs.py
  @numpy_cache("momentum_cache")
  def sample_momenta(sample_num, interval, charge, esp, seed=None, **kwargs):
      """Samples `sample_num` unweighted photon 4-momenta from the
      cross-section. Superflous kwargs are passed on to
      `sample_unweighted_array`.

      :param sample_num: number of samples to take
      :param interval: cosθ interval to sample from
      :param charge: the charge of the quark
      :param esp: center of mass energy
      :param seed: the seed for the rng, optional, default is system
          time

      :returns: an array of 4 photon momenta

      :rtype: np.ndarray

      """

      cosθ_sample = monte_carlo.sample_unweighted_array(
          sample_num, lambda x: diff_xs_cosθ(x, charge, esp), interval_cosθ, **kwargs
      )

      φ_sample = np.random.uniform(0, 1, sample_num)

      def make_momentum(esp, cosθ, φ):
          sinθ = np.sqrt(1 - cosθ ** 2)
          return np.array([1, sinθ * np.cos(φ), sinθ * np.sin(φ), cosθ],) * esp / 2

      momenta = np.array(
          [make_momentum(esp, cosθ, φ) for cosθ, φ in np.array([cosθ_sample, φ_sample]).T]
      )
      return momenta
#+end_src

#+RESULTS:

To generate histograms of other obeservables, we have to define them
as functions on 4-impuleses. Using those to transform samples is
analogous to transforming the distribution itself.
#+begin_src jupyter-python :session obs :exports both :results raw drawer :tangle tangled/observables.py
  """This module defines some observables on arrays of 4-pulses."""
  import numpy as np
  from utility import minkowski_product


  def p_t(p):
      """Transverse momentum

      :param p: array of 4-momenta
      """

      return np.linalg.norm(p[:, 1:3], axis=1)


  def η(p):
      """Pseudo rapidity.

      :param p: array of 4-momenta
      """

      return np.arccosh(np.linalg.norm(p[:, 1:], axis=1) / p_t(p)) * np.sign(p[:, 3])


  def inv_m(p_1, p_2):
      """Invariant mass off the final state system.

      :param p_1: array of 4-momenta, first fs particle
      :param p_2: array of 4-momenta, second fs particle
      """

      total_p = p_1 + p_2
      return np.sqrt(minkowski_product(total_p, total_p))


  def cosθ(p):
      return p[:, 3] / p[:, 0]

  def o_angle(p_1, p_2):
      eta_1 = η(p_1)
      eta_2 = η(p_2)

      return np.abs(np.tanh((eta_1 - eta_2) / 2))

  def o_angle_cs(p_1, p_2):
      eta_1 = η(p_1)
      eta_2 = η(p_2)
      pT_1 = p_t(p_1)
      pT_2 = p_t(p_2)
      total_pT = p_t(p_1 + p_2)
      m = inv_m(p_1, p_2)

      return np.abs(
          np.sinh(eta_1 - eta_2)
          ,* 2
          ,* pT_1
          ,* pT_2
          / np.sqrt(m ** 2 + total_pT ** 2)
          / m
      )
#+end_src

#+RESULTS:

And import them.
#+begin_src jupyter-python :exports both :results raw drawer
  %aimport tangled.observables
  obs = tangled.observables
#+end_src

#+RESULTS:

Lets try it out.
#+begin_src jupyter-python :exports both :results raw drawer
  momentum_sample = sample_momenta(
      sample_num,
      interval_cosθ,
      charge,
      esp,
      proc='auto',
      momentum_cache="cache/momenta_bare_cos_θ_1",
  )
  momentum_sample
#+end_src

#+RESULTS:
:RESULTS:
: Loading Cache:  sample_momenta
: array([[100.        ,  43.62555709,  21.21790392, -87.44490449],
:        [100.        ,  41.38722348,  52.29638318, -74.51299242],
:        [100.        ,  52.85217407,  65.6183037 , -53.85987297],
:        ...,
:        [100.        ,  49.13037192,  24.63978227, -83.54093419],
:        [100.        ,  66.19768512,  12.47637819,  73.90674173],
:        [100.        ,  22.11649396,  29.96005732, -92.80762717]])
:END:


Now let's make a histogram of the η distribution.
#+begin_src jupyter-python :exports both :results raw drawer
  η_sample = obs.η(momentum_sample)
  fig, ax, hist_obs_η = draw_histo_auto(
      η_sample, r"$eta$", range=interval_η, rethist=True
  )
  save_fig(fig, "histo_eta", "xs_sampling", size=[3, 3])
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/0cefb0de82a158b41c584233d998e73661627b2f.png]]


And the same for the p_t (transverse momentum) distribution.
#+begin_src jupyter-python :exports both :results raw drawer
  p_t_sample = obs.p_t(momentum_sample)
  fig, ax, hist_obs_pt = draw_histo_auto(
      p_t_sample, r"$p_T$ [GeV]", range=interval_pt, rethist=True
  )
  save_fig(fig, "histo_pt", "xs_sampling", size=[3, 3])
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/bfee9d12cdae264248514daef92e83a4b737e49c.png]]

That looks somewhat fishy, but it isn't.
#+begin_src jupyter-python :exports both :results raw drawer
  fig, ax = set_up_plot()
  points = np.linspace(interval_pt[0], interval_pt[1] - .01, 1000)
  ax.plot(points, gev_to_pb(diff_xs_p_t(points, charge, esp)))
  ax.set_xlabel(r'$p_\mathrm{T}$')
  ax.set_xlim(interval_pt[0], interval_pt[1] + 1)
  ax.set_ylim([0, gev_to_pb(diff_xs_p_t(interval_pt[1] -.01, charge, esp))])
  ax.set_ylabel(r'$\frac{\mathrm{d}\sigma}{\mathrm{d}p_\mathrm{T}}$ [pb]')
  save_fig(fig, 'diff_xs_p_t', 'xs_sampling', size=[4, 2])
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/5c39a14515ced9b3f1d5d0cdd0c4fe75921ee3a7.png]]
this is strongly peaked at p_t=100GeV. (The jacobian goes like 1/x there!)

*** Sampling the η cross section
An again we see that the efficiency is way, way! better...
#+begin_src jupyter-python :exports both :results raw drawer
  η_sample, η_efficiency = monte_carlo.sample_unweighted_array(
      sample_num,
      dist_η,
      interval_η,
      report_efficiency=True,
      proc="auto",
      cache="cache/sample_bare_eta_1",
  )
  tex_value(
      η_efficiency * 100,
      prefix=r"\mathfrak{e} = ",
      suffix=r"\%",
      save=("results", "eta_eff.tex"),
  )
#+end_src

#+RESULTS:
:RESULTS:
: Loading Cache:  sample_unweighted_array
: \(\mathfrak{e} = 41\%\)
:END:
<<η-eff>>

Let's draw a histogram to compare with the previous results.
#+begin_src jupyter-python :exports both :results raw drawer
  η_hist = np.histogram(η_sample, bins=50)
  fig, (ax_hist, ax_ratio) = draw_ratio_plot(
      [
          dict(hist=η_hist, hist_kwargs=dict(label=r"sampled from $\mathrm{d}\sigma / d\eta$"),),
          dict(
              hist=hist_obs_η,
              hist_kwargs=dict(
                  label=r"sampled from $\mathrm{d}\sigma / d\cos\theta$", color="black"
              ),
          ),
      ],
  )

  ax_hist.legend(loc="upper center", fontsize="small")
  ax_ratio.set_xlabel(r"$\eta$")
  save_fig(fig, "comparison_eta", "xs_sampling", size=(4, 4))
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/c2d46c9b5db725200662f8070e8fafbb0199f5b7.png]]

Looks good to me :).

*** Sampling with =VEGAS=
To get the increments, we have to let =VEGAS= loose on our
distribution. We throw away the integral, but keep the increments.

#+begin_src jupyter-python :exports both :results raw drawer
  K = 10
  increments = monte_carlo.integrate_vegas(
      dist_cosθ, interval_cosθ, num_increments=K, alpha=1, increment_epsilon=0.01
  ).increment_borders
  tex_value(
      K, prefix=r"K = ", save=("results", "vegas_samp_num_increments.tex"),
  )
  increments
#+end_src

#+RESULTS:
: array([-0.9866143 , -0.96916115, -0.9297287 , -0.8368118 , -0.60013666,
:         0.00111691,  0.59866117,  0.83547058,  0.93009757,  0.96938499,
:         0.9866143 ])

Visualizing the increment borders gives us the information we want.
#+begin_src jupyter-python :exports both :results raw drawer
  pts = np.linspace(*interval_cosθ, 100)
  fig, ax = set_up_plot()
  ax.plot(pts, dist_cosθ(pts))
  ax.set_xlabel(r'$\cos\theta$')
  ax.set_ylabel(r'$\frac{\mathrm{d}\sigma}{\mathrm{d}\Omega}$')
  ax.set_xlim(*interval_cosθ)
  plot_increments(ax, increments,
                  label='Increment Borderds', color='gray', linestyle='--')
  ax.legend()
#+end_src

#+RESULTS:
:RESULTS:
: <matplotlib.legend.Legend at 0x7f897b6cf9a0>
[[file:./.ob-jupyter/ab9fdc8943d59f77ea4d3e89b4acf56e6967e8cf.png]]
:END:

We can now plot the reweighted distribution to observe the variance
reduction visually.

#+begin_src jupyter-python :exports both :results raw drawer
  pts = np.linspace(*interval_cosθ, 1000)
  fig, ax = set_up_plot()
  ax.plot(pts, dist_cosθ(pts), label="Distribution")
  plot_vegas_weighted_distribution(
      ax, pts, dist_cosθ(pts), increments, label="Weighted Distribution"
  )
  ax.set_xlabel(r"$\cos\theta$")
  ax.set_ylabel(r"$\frac{\mathrm{d}\sigma}{\mathrm{d}\cos\theta}$")
  ax.set_xlim(*interval_cosθ)
  plot_increments(
      ax, increments, label="Increment Borderds", color="gray", linestyle="--"
  )
  ax.legend(fontsize="small")
  save_fig(fig, "vegas_strat_dist", "xs_sampling", size=(3, 2.3))
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/deca4f34c00da181d0dd97eb9bb340d80336f78a.png]]


I am batman! Let's plot the weighting distribution.
#+begin_src jupyter-python :exports both :results raw drawer
  pts = np.linspace(*interval_cosθ, 1000)
  fig, ax = set_up_plot()
  plot_stratified_rho(ax, pts, increments)
  ax.set_xlabel(r"$\cos\theta$")
  ax.set_ylabel(r"$\rho$")
  ax.set_xlim(*interval_cosθ)
  save_fig(fig, "vegas_rho", "xs_sampling", size=(3, 2.3))
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/c4f803471d6c9ad54693a866fd4e16edd7788e6c.png]]

Now, draw a sample and look at the efficiency.

#+begin_src jupyter-python :exports both :results raw drawer
  cosθ_sample_strat, cosθ_efficiency_strat = monte_carlo.sample_unweighted_array(
      sample_num,
      dist_cosθ,
      increment_borders=increments,
      report_efficiency=True,
      proc="auto",
      cache="cache/sample_bare_cos_theta_vegas_1",
  )
  cosθ_efficiency_strat
#+end_src

#+RESULTS:
:RESULTS:
: Loading Cache:  sample_unweighted_array
: 0.599386385426654
:END:

#+begin_src jupyter-python :exports both :results raw drawer
  tex_value(
      cosθ_efficiency_strat * 100,
      prefix=r"\mathfrak{e} = ",
      suffix=r"\%",
      save=("results", "strat_th_samp.tex"),
  )
#+end_src

#+RESULTS:
: \(\mathfrak{e} = 60\%\)

If we compare that to [[cosθ-bare-eff]], we can see the improvement :P.
It is even better the [[η-eff]].  The histogram looks just the same.

#+begin_src jupyter-python :exports both :results raw drawer
fig, _ = draw_histo_auto(cosθ_sample_strat, r'$\cos\theta$')
save_fig(fig, 'histo_cos_theta_strat', 'xs', size=(4,3))
#+end_src

#+RESULTS:
[[file:./.ob-jupyter/e5a0b48e734e9986fe341dfd1ada1c6e25840b90.png]]

*** Some Histograms with Rivet
**** Init
#+begin_src jupyter-python :exports both :results raw drawer
  import yoda
#+end_src

#+RESULTS:

**** Plot the Histos
#+RESULTS:

#+begin_src jupyter-python :exports both :results raw drawer :tangle tangled/plot_utils.py
  def yoda_to_numpy(histo):
      edges = histo.xEdges()
      heights = np.array([bi.numEntries() for bi in histo])

      return heights, edges


  def draw_yoda_histo_auto(h, xlabel, **kwargs):
      hist = yoda_to_numpy(h)
      fig, ax = set_up_plot()
      draw_histogram(ax, hist, errorbars=True, normalize_to=1, **kwargs)

      ax.set_xlabel(xlabel)
      return fig, ax
#+end_src

#+RESULTS:

#+begin_src jupyter-python :exports both :results raw drawer
  yoda_file = yoda.read("../../runcards/qqgg/analysis/Analysis.yoda")
  sherpa_histos = {
      "pT": dict(reference=hist_obs_pt, label="$p_T$ [GeV]"),
      "eta": dict(reference=hist_obs_η, label=r"$\eta$"),
      "cos_theta": dict(reference=hist_cosθ, label=r"$\cos\theta$"),
  }

  for key, sherpa_hist in sherpa_histos.items():
      yoda_hist = yoda_to_numpy(yoda_file["/MC_DIPHOTON_SIMPLE/" + key])
      label = sherpa_hist["label"]
      fig, (ax_hist, ax_ratio) = draw_ratio_plot(
          [
              dict(
                  hist=yoda_hist,
                  hist_kwargs=dict(
                      label="Sherpa Reference"
                  ),
                  errorbars=True,
              ),
              dict(
                  hist=sherpa_hist["reference"],
                  hist_kwargs=dict(label="Own Implementation"),
              ),
          ],
      )
      ax_ratio.set_xlabel(label)
      ax_hist.legend(fontsize='small')
      save_fig(fig, "histo_sherpa_" + key, "xs_sampling", size=(4, 3.5))
#+end_src

#+RESULTS:
:RESULTS:
[[file:./.ob-jupyter/967297ba71050b1316860db3fc349c2a21e666dd.png]]
[[file:./.ob-jupyter/0282ddfc048582ec8d56d652425aac26712be109.png]]
[[file:./.ob-jupyter/790a478225f5c1238d00631db758bfa987abfa7c.png]]
:END:
